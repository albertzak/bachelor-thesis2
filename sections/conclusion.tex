\cleardoublepage
\section{Future Work}

The implementation of the node agent described in this work is a proof of concept. Further work is needed before the pipeline is fit be used in a production setting.

Every release artifact must include a full copy of the \acrshort{erts}, and the node agent always downloads the full package before each upgrade. In order to stay compatible with other \acrshort{otp} tooling while optimizing for bandwidth, the store may rebuild the generated tarball using a packing algorithm that allows efficient binary diffing of compressed artifacts.
Large deployments may also benefit from a peer-to-peer release distribution mechanism, using e.g. BitTorrent.

Configuration management was only touched upon lightly in this work and relies on files baked into the release artifacts. Since such configuration often includes sensitive data, more research is needed on how to merge the notion of \acrshort{dsu} with changing configuration at the same time; while ideally separating the delivery of software from delivery of its configuration. A node should only require a one-time setup phase where it is assigned an immutable, unique identifier. The node then uses this token to dynamically fetch all other configuration from an external service, authenticate with the store, and download releases.

While Erlang/OTP provides a way to synchronize the upgrade process between distributed nodes, there are no mechanisms for synchronizing rollback. If an upgrade fails on some of the machines and causes them to reboot with the previous release, the distributed system is left running inconsistent versions. Node agents running next to the operational nodes could form an overlay network to decide whether to perform rollbacks on all other nodes in this case.

Further research into upgrade safeness properties of Erlang/OTP systems is needed. Static linter tools could help catch common mistakes such as infinitely blocking receive clauses. To identify possibly breaking changes in record definitions for example, a more sophisticated heuristic code analysis tool may take a module's history from source control into account. Finally, online instrumentation on running nodes may provide a notion of transparently versioned message passing between Erlang processes, and help in determining the point in time when it is safe to remove deprecated message handling code.

% --
\cleardoublepage
\section{Conclusion}

This work has shown how the manual steps of deploying and upgrading an Erlang/\acrshort{otp} node can be automated. The contribution is an extension to the \acrshort{cli} tool \emph{BeamUp} to set up an Erlang node with one command that subscribes to a central release store and continuously pulls and deploys \acrshort{otp} Releases via \acrshort{dsu}.

Testing and evaluation of the prototype implementation has revealed many potential sources of errors that complicate many areas of service delivery. Some of these issues may be solved by developing more advanced tooling and stronger runtime support.

Unless the problem domain requires lots of in-memory state, e.g.~in a game server; or the system maintains persistent connections that cannot easily be drained, e.g.~a routing middleware, adding \acrshort{dsu} capabilities to a system must be thoroughly weighted against the additional complexity in development, deployment, and operations.
