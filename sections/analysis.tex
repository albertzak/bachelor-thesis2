\cleardoublepage
\section{Failure Analysis}


\subsection{Test Setup}


\subsection{Issues Caused by Old Code}
% TODO Map to Hick's "Assumptions"

This is the most severe class of issues, as they may prevent any Release Upgrades from being applied. If these concerns were not taken care of at the time when the previous version was developed, any nodes running that code cannot be upgraded without losing at least part of their state -- meaning some processes may have to be forcibly terminated, or cause other processes to terminate unexpectedly, or the whole emulator may have to reboot.

\paragraph{Infinitely blocking receive clauses.}
By default, an Erlang process expecting a particular message blocks forever until it successfully pattern matches on the received term. Recall that the \acrshort{beam} can keep up to two versions of a module loaded in memory at once. Any processes running the oldest version while a third newer one is loaded are killed because the oldest module is purged from memory. In the case of Release Upgrades, either some processes' state is lost or the upgrade will not be applied. Using the default process purge strategy \lstinline|brutal_purge|, old processes are killed; while \lstinline|soft_purge| aborts the upgrade if any processes are running old code.

\paragraph{No fully qualified calls.}
Resident modules –- i.e.~those that have processes running a tail-recursive loop –– must handle the \lstinline|change_code| system message themselves and upon receipt perform a fully-qualified call (prepend the module name with a colon, \lstinline|module:function()|). Alternatively, if it is known beforehand that no state upgrade will be needed, it is sufficient to continuously perform fully qualified calls within at least the upgrade timeout, which defaults to five seconds.

\paragraph{Anonymous functions.}
Processes can pass anonymous functions to other processes running even on different nodes. Despite their unimpeded freedom of movement, anonymous functions are tied to the exact version of the module they were defined in. This fact is not obvious to the developer, and has unfortunate consequences when the module that defined the function gets purged. Process $A$ puts an anonymous function defined in module $A_1$ into process $B$'s mailbox. As part of an upgrade, module $A_1$ is replaced by module $A_2$, and process $A$ is given a chance to upgrade its state. After the old module $A_1$ is purged from memory, as soon as process $B$ attempts to execute the received function, it will exit with reason \lstinline|badfun|. While~\cite{davis:talk} stated that the receiving process does not even have to execute the function to cause the issue; testing with Erlang/OTP 20 showed that the process only exits when it attempts to execute the function, but can parse the rest of the message just fine.

When designing \acrshort{api}s,~\cite{davis:talk} recommends to take an \lstinline|{M, F, A}| triple (\acrlong{mfa}) instead of an anonymous function as a reference to an exported function independent of its defining modules' version. When passing references to exported functions between nodes, it is sufficient that the module is loaded on the node where the function is to be called. Erlang and Elixir also implement a shorthand syntax for capturing module-level functions, which appears to behave equivalent to passing an \lstinline|{M, F, A}| triple. Note that in either case no closure can be passed along with module-level functions.


\paragraph{Required OTP dependencies.}
In order to unpack and install a Release Upgrade on a target system, the \lstinline|release_handler| module needs to be available and loaded on the node. This module is part of the \acrfull{sasl} application which needs to be explicitly listed as a dependency of the initial release. Most third party release assembly tools print a warning if the SASL application is not included when building a release package.
The build tool described in~\cite{zak18} silently adds a dependency on the SASL application before building the project, and ensures the \acrshort{erts} is included in the release package.
The target system also needs to be started with heartbeat monitoring in order to properly handle upgrade instructions that require the node to perform a restart.~\cite{doc:otp}

\subsection{Issues Caused by New Code}

\paragraph{Old messages in mailboxes.}
Messages may exist in processes' mailboxes for a long time. New modules must retain the ability to handle messages generated by up to $n-1$ previous versions of themselves. If a process running a new version of a module can no longer recognize older messages, it throws a pattern match exception. There is currently no built-in runtime support for versioned messages, a feature which would enable tooling to determine the point in time when old message handling code is no longer needed for a particular module.

\paragraph{Records.}
Processes commonly keep their state inside a \emph{record} data structure. This allows easy access to arbitrary key-value pairs in an unordered way. Records are a not a core data type in Erlang. They are just syntactical sugar over tuples, which are inherently ordered data structures. These tuples contain only the name of the record definition and the respective values. There is no built-in notion of versioning.

For example, a record defined by \lstinline|-record(person, {name, age}).| is desugared to a tuple in the form of \lstinline|{person, a, 99}|. A developer wishing to add, rename, delete, or move a field of a record definition must either extract data from the underlying tuple representation and use that to populate a new record; or to define a new record with a different name while keeping the old record definition and name intact. The code change callback must then create a new record and imperatively copy over the previous values.

The problem is exacerbated when record definitions are made public via Erlang header files (*.hrl) because then consumers of this record definition must know when and how to upgrade their records.~\cite{davis:talk} A solution contributed by~\cite{wiger:parsetrans} relies on parse transformations to add a notion of versioning to records, and a way to automatically infer and perform the required steps to convert between representations, given that no fields were renamed but only added, moved, or deleted. Alternatively, since the introduction of \emph{maps} in R17, Erlang/OTP supports a proper first class key-value data type. Developers are encouraged to use maps instead of records, but many dependencies –– including some core applications –– still rely on records.

\paragraph{Emulator version upgrades.} It is possible to update the version of the \acrfull{erts} or any of the core applications (kernel, stdlib, or sasl) as part of a Release Upgrade. However, this is not a \acrshort{dsu} action. When the release handler encounters the \lstinline|restart_new_emulator| instruction, it shuts down the currently running node and starts the new version of the \acrshort{erts} including the new core applications. This new emulator still runs the old versions of the previous releases' other applications. Finally, the release handler performs the rest of the upgrade instructions on the new node to upgrade the applications. There is also a \lstinline|restart_emulator| instruction that skips the second step of upgrading applications and instead boots the new emulator with all applications at their latest versions.

\paragraph{Third party dependencies.}


\paragraph{Non-upgradeable applications.}
Some applications do not need to be upgraded using \acrshort{dsu}



\paragraph{Rollbacks.} If a code change callback throws or returns an error, or if any other functions called as part of the upgrade process fail, the node will simply reboot using the old versions of the applications.




\subsection{Issues Caused by Tooling}

\paragraph{No atomic loading of modules.}
Installation of Release Upgrades is a sequential process. Modules are loaded, and processes are upgraded in the order defined in the \acrshort{relup} file.

\paragraph{Appup generation.}
%

\paragraph{One-off tasks in Elixir.}
Production systems sometimes need to run administrative commands to perform tasks such as database migrations. It is possible to manually trigger them by attaching a shell to the production node, but most tools that expect an Elixir project folder cannot work with OTP releases. There is a difference between the folder structure of Elixir projects in development when using the default \lstinline|mix| build tool compared to a compiled OTP release. Additionally, the default Elixir configuration file \lstinline|config.exs| is evaluated at release assembly time and converted to Erlang configuration. Yet, some plugins for \lstinline|mix| expect an Elixir project structure or Elixir configuration even in production deployments. For example, database migrations in Elixir using Ecto are usually performed via a \lstinline|mix| task, which is not available inside releases. Developers of Elixir projects wishing to take advantage of the proposed deployment architecture need to take care to set up e.g.~migrations to run automatically. In the future, \lstinline|mix| will likely move towards a folder structure resembling releases in development, which will ease interoperability of administrative tasks.~\cite{mix_releases}



\subsection{Other Considerations}

\paragraph{Version numbers.}
Each application that is part of a release must define a version string inside its application resource file (*.app), and the release package itself has another independent version identifier specified inside the release resource file (*.rel). Applications that had their modules changed between releases must change their version number. The version identifier of two different releases must also change. Many release assembly tools provide a way of programmatically generating the version numbers e.g.~by using the git commit hash, but in order to successfully apply an Upgrade Release the version strings must additionally be sortable in a way that newer versions have higher version numbers.


\paragraph{Changing supervisors.}
There is a dedicated upgrade instruction to change the parameters of a callback module implementing the supervisor behaviour, but any changes only apply to newly spawned children of that supervisor. If required, existing child processes must be modified with a custom function call given via an \lstinline|apply| instruction.

\paragraph{Native dependencies.}
Erlang programs may communicate with other native software via e.g.~ports. When such programs are packaged as part of a release, Erlang code can retrieve their path via \lstinline|code:priv_dir(App)|. If the native program needs to be changed as part of an upgrade, the \lstinline|code_change| callback needs to extract state from the external program, close the port, manually upgrade the native binary, and then reopen the port, without special support from \acrshort{otp}.

\paragraph{Partial \acrshort{dsu}.}
Different parts of a system may have varying uptime requirements. Some applications, for example libraries or non-critical applications, may not need to be upgraded using \acrshort{dsu}. Rather it is acceptable if they are simply restarted to the new version via the \lstinline|restart_application| instruction. Loosening the requirement to perform \acrshort{dsu} only on the most critical parts of the system can make the overall upgrade process more stable.
