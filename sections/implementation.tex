\section{Implementation}

The contribution of this work is an extension to the tool \emph{BeamUp}~\cite{zak18} for bootstrapping an Erlang node to start an OTP Release with a single command, and to continuously apply Release Upgrades to the running system without user interaction using Erlang/OTP's built-in support for \acrshort{dsu}. The \emph{node agent} is written in Erlang, and runs on a separate \acrshort{beam} instance side by side to the \emph{operational node}. The agent subscribes to a central store to fetch release packages, caches them locally, and boots, controls, and monitors the operational node.

% TODO: Figure of the two BEAMs

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[>=latex']
    \tikzset{block/.style={
      draw,
      rectangle,
      align=center,
      minimum width=2.8cm,
      minimum height=1cm
    }};

    \node [block] (cli) {CLI};
    \node [block, right=1cm of cli] (builder) {Builder};
    \node [block, right=4cm of builder] (store) {Store};

    \path[draw,->] (cli) edge (builder);
    \path[draw,<-] (builder.10) -- (store.170);
    \path[draw,->] (builder.350) -- (store.190);

  \end{tikzpicture}
  \caption{Architecture outline.}\label{fig:impl}
\end{figure}

The following subsections explain the changes made to the release store and \acrshort{cli} tool, the bootstrapping process, how the node agent is implemented, and how the agent interacts with the operational node.

\subsection{Store}


\paragraph{Release name.}
OTP has no notion of a project; the most coarse level of organization is a Release, which is given a name. Multiple distinct Releases comprising different Applications may be generated from a single codebase, each bearing a unique name. For example, individual nodes in a distributed setup may run separate Releases with distinct configurations. The build tool described in~\cite{zak18} ignored this fact and generated only one release, always picking the name of the containing folder (the project name) as the name for the release. An artifact was identified by the combination of project name, release version, machine architecture, and git branch. All \acrshort{api}s now additionally take into consideration the release name, defaulting to the project name if left unspecified.

\paragraph{Notifications.} The store now provides an additional endpoint through which nodes can subscribe to be notified when new artifacts are available. The notification system is based on the \acrfull{sse} standard, with the payload message encoded in \acrfull{etf}. Decoding the update notification yields a tagged tuple containing the just latest version string. The new binary release package needs to be fetched separately via the existing single artifact \acrshort{http} GET endpoint.

\input{sections/fig_store_api}

\subsection{Bootstrapping}
The invocation of the \acrshort{cli} tool to start a node running the latest version of a particular project is given in Listing~\ref{lst:node}. The node is pointed at the release store via environment variables, optionally supplying a shared authentication token, and is told what project and optionally what release name to run. Note that this command only needs to be run once, except after a reboot of the host. The node subscribes to the store to be notified of new versions, and downloads and applies them without user interaction.

\begin{lstlisting}[
  label={lst:node},
  caption={Minimal node bootstrap command.}
]
BEAMUP_NODE_PROJECT_NAME=mychat \
BEAMUP_STORE=https://store.example.com \
beamup node
\end{lstlisting}

\paragraph{Transparent container invocation.}
All \lstinline|beamup| \acrshort{cli} commands are either executed directly on the host, or, if possible, passed into a newly started container where they run in a well-defined environment. If it is not possible to start containers –– which is the case if the tool is being started inside an already-running container –– then it must assume that the \acrshort{erts} is  set up correctly on the machine. This is why the tool prefers to pass execution into a well-known container, where the same command is then ran again. Once inside, the tool can safely proceed under the assumption that the environment is correct.~\cite{zak18}


\paragraph{Container privileges.}
The container is started in privileged mode and with host networking. This means that no port mapping is required or even possible. The container shares the same \acrshort{ip} address as the host, and can listen on all unprivileged ports except those used by other programs running on the host. The same applies to other devices attached to the host machine, they are accessible from within the container. The advantage of starting the node with this command is its simplicity, as the fact that the operational node is running inside a container becomes mostly transparent to the user.

\paragraph{Bare node container.}
The command in Listing~\ref{lst:node} is not suitable for deploying more complex services, as there is no way of arbitrarily accessing the host's file system, or restricting access to the host's devices. At the same time, the container has access to the host networking stack, which poses a security risk because the container can write to, for example the host's D-bus.~\cite{docker:docs}

For production deployments, it is thus recommended to start the provided general purpose \lstinline|beamup/node| container from the Docker Hub and configure its privileges and port mappings accordingly using any container orchestration tool. Doing so has the additional advantage of locking down the container's environment and communication capabilities in a declarative way.

When the container is started, the same node command is invoked inside. Note that the version of Erlang/OTP which ships with the image is only relevant to the node agent, because the operating node will use the version of the \acrshort{erts} bundled with the release package, and the two \acrshort{beam}s running inside a node share nothing.

\paragraph{Environment variables}
% Table

\paragraph{Node identification}
% Cookie, Node name


\subsection{Release Packages}

The node agent maintains two persistent directories which are mapped to the host file system: \begin{enumerate}[label=(\roman*)]
  \item a local cache of release package tarballs in \lstinline[breaklines=true]|~/.beamup/node/releases|,
  \item and one operating directory containing the current target system in \lstinline[breaklines=true]|~/.beamup/node/active|.
\end{enumerate}

On startup, the agent attempts to start a node from the operating directory. In case of a first run, or when there is no valid release found inside the operating directory, the supervising process yields. If an operational node can be started, the agent does not yet care what version it is running.

In any case, the agent meanwhile connects to the store and retrieves the latest version metadata of the requested combination of project name, release name, machine architecture, and git branch.

When the latest version happens to be the same as the one inside the operating directory, it has already been started and no further action is needed. Otherwise, the latest package is either fetched from the local release cache, or downloaded and stored before it is unpacked to the operating directory.

If there is no latest version of the requested artifact present in the remote store, the agent prints a warning and yields. Nonetheless, it subscribes to be notified when a matching package is published.


\paragraph{Extracting release packages.}
When unpacking a release, the agent must take care to use the correct method: If the operating directory contains a valid target system, the agent must call the release handler of the operational node to properly unpack the new release on top of the currently running one. This is important because the \lstinline|RELEASES| file in the operating directory contains metadata about all of the releases that are currently available to the node. Yet the release package which is to be extracted on top of the operating folder contains another \lstinline|RELEASES| file, which may not overwrite the existing one. Their contents must be properly merged by the release handler, as the new release will be marked as ``unpacked, but not yet installed'', and the old release metadata must remain inside this file. The release handler also performs some sanity checks for missing files on the release package before extracting. On the other hand, if there is no target system available in the operating folder, the package is simply unpacked using \lstinline|tar|.

\subsection{Node Agent}

The node agent is responsible for starting and upgrading the operational node. It runs on a separate instance of the \acrshort{beam} side by side to the operational node, and is designed to be minimally intrusive. Communication only happens via the target system's exposed convenience scripts inside its \lstinline|bin| directory. When a release is to be upgraded, for example, the node agent spawns another OS-level process of the system's shell, calling the \lstinline|bin/upgrade| script with the required parameters, and waiting for it to terminate. This
degree of separation may appear inefficient, as the node agent could just join the operational node using a hidden shell and directly interact with the release handler. Yet, by only assuming the existence of the informal \acrshort{api} exposed by the scripts in \lstinline|bin|, whatever tool used to assemble the release can define exactly how the upgrade should take place.



The node agent does not listen on any ports, and does not attempt to join other agents or the operational node's cluster by default. This is to allow the operational node to transparently interact with the host's networking stack by not causing unexpected port collisions when the node is started via the convenience command.


\paragraph{Attaching a shell.}
To perform tracing on a live system, administrators can attach a shell to either the node agent or


\subsection{Release Upgrades}

\subsection{Synchronized Rollback}
When hot upgrading a distributed system, it is often desirable to minimize the time where different versions of the code are in concurrent use.
