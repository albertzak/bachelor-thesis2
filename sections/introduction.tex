\section{Introduction}

The contribution of this work consists of two parts. \begin{enumerate*}[label=(\roman*)]
  \item First, an extension to the pipeline described in~\cite{zak18} to bootstrap an Erlang/\acrshort{otp} (\emph{\acrlong{otp}}) node with a single command. The node consists of an agent and an operational node running as separate processes inside a container. The agent continuously pulls release packages from a central store and deploys them without user interaction.
  \item Second, an analysis of possible failure modes and root causes that may prevent an Erlang release upgrade from being applied successfully via \acrfull{dsu}.
\end{enumerate*}

This section explains relevant Erlang terminology and shows where manual interaction is required to deploy \acrshort{otp} Releases.

\subsection{Erlang/OTP}

Erlang is a programming language for building concurrent, distributed systems with high availability requirements. Initially designed by Ericsson for telephone exchanges, it has been embraced by industries with similar needs: finance, gaming, betting, messaging, middleware, and databases. Development of Erlang took place starting in 1986 at the Ericsson Computer Science Laboratory, and in 1998 Erlang was released as Open Source.~\cite{armstrong2007history}

\acrshort{otp} stands for \acrlong{otp}, and is a combination of library applications, design patterns, conventions, and documentation. Erlang is almost always used in conjunction with \acrshort{otp}, hence the name Erlang/\acrshort{otp}.~\cite{ferd}

The language is often described as functional, although it is not strictly side effect free or referentially transparent. Erlang compiles to bytecode, which is executed by a \acrfull{vm}. The current Erlang \acrshort{vm} – the \emph{\acrshort{beam}}, short for \emph{\acrlong{beam}} – is written in C and supports various machine architectures. Multiple languages that compile to \acrshort{beam} bytecode have been created, most famously \emph{Elixir} and \emph{Lisp Flavored Erlang}. Actor model processes are the language's concurrency primitives: Functions can be spawned to create lightweight \acrshort{beam} processes. They are different from \acrfull{os} processes or threads, being preemptively scheduled by the \acrshort{beam}. Erlang/\acrshort{otp} systems commonly ``run millions of processes simultaneously [with each one taking] less than a kilobyte of space.''~\cite{larson}

\cleardoublepage
\paragraph{Structure.}
Erlang code is constructed out of functions defined within \mbox{\emph{module}} files bearing an \lstinline|*.erl| extension. Modules compiled to \acrshort{beam} bytecode have a \lstinline|*.beam| extension. \emph{\acrshort{otp} Applications} group related modules into reusable units. \acrshort{otp} also enforces a certain directory structure for applications.~\cite{logan:otp} Whole projects consisting of multiple applications are packaged and deployed as \acrshort{otp} Releases. Various tools can be used to assemble the release into a single compressed tarball (\lstinline|*.tar.gz|) package.~\cite{doc:otp} A packaged release contains everything necessary to bootstrap an \emph{embedded target system} on another machine, also called a \emph{node}. Depending on the tool used to generate the release, it may include additional convenience scripts to upgrade or inspect the target system.

\paragraph{\acrlong{dsu}.} Highly available distributed systems are often realized using a rolling deployment model where nodes are upgraded one after another, with load balancers attempting to gently drain connections from old services and direct new connections to recently upgraded nodes. This may be undesirable for long-running sessions, or servers with lots of in-memory state. A core feature of Erlang is its support for \acrfull{dsu}, also referred to as on-the-fly upgrading, or hot code loading.

The \acrshort{beam} keeps up to two versions of a module loaded in memory, and both versions of the code may run side by side.~\cite{cesarini:otp} Orchestrating changes to a running production system in a controlled way is done via a \acrfull{relup} file, which accompanies a release package and is compiled from multiple \acrfull{appup} files of each changed OTP Application part of the release.

A target system capable of \acrshort{dsu} must provide a release handler process. This process is part of the OTP \acrfull{sasl} Application and handles unpacking, installing, upgrading, and removing release packages from within a running node.

\cleardoublepage
\subsection{Problem}\label{sec:problem}
The deployment process of Erlang/OTP systems is at odds with modern \acrfull{cd} tooling when \acrshort{dsu} capabilities are required. A single build of a software is generally expected to be an immutable, self-contained unit of deployment which needs to be started, stopped, and replaced between each update. This is orthogonal to how Erlang/OTP approaches deployment: Nodes expect to run continuously and have access to a mutable directory where compiled modules packaged as OTP Releases can be swapped in and out as required during the lifetime of the system. Immutable, versioned containers are not fit as deployment primitives in a \acrshort{dsu} system.

Additionally, OTP tooling expects operators to perform various manual steps to hot upgrade an Erlang target system. One needs to transfer the correct release package to the server, unpack it using one of two methods depending on whether it is the first release or an upgrade, attach a shell to the emulator and invoke various commands in the correct order and with the right arguments, including different version strings.
This process is tedious and error-prone to perform manually, and impedes frequent deployment of small changes. Likewise, complex code changes are more likely to fail when applied via \acrshort{dsu}.~\cite{hicks} The unfortunate consequence is that developers are discouraged from using Erlang's \acrshort{dsu} capabilities unless absolutely necessary.~\cite{ferd} To take advantage of the various benefits of Continuous Delivery together with Erlang/OTP's \acrshort{dsu} capabilities, developers must first spend time automating these steps for each project.

\cleardoublepage
\subsection{Contribution}

This work contributes design, implementation and evaluation of an extension to the build tool described in~\cite{zak18} for deploying Erlang/\acrshort{otp} Releases with support for \acrshort{dsu}. Its aim is to be a general purpose deployment pipeline that runs without user interaction and requires as little configuration as possible.

\paragraph{Goal.} The goal is to develop a prototype implementation for bootstrapping an Erlang node with a single command. The node agent subscribes to the previously described release store to fetch release packages, download, extract, and deploy them; as well as apply \acrshort{dsu} instructions.

\paragraph{Method.} The thesis describes the architectural and design decisions made while iteratively implementing said node agent. The prototype is then used to test and analyze the boundaries of the \acrshort{dsu} process. Additionally, this work includes a critical discussion of the contribution in regards to its advantages and limitations.

\cleardoublepage
\subsection{State of the Art}\label{sec:sota}

The seemingly modern idea of bootstrapping infrastructure was first thoroughly documented by~\cite{traugott1998bootstrapping}. More recently,~\cite{adams2016modern} provided a good overview of the state of the art in the practice of modern automated build and deployment models, commonly referred to as \acrfull{cd}. Most literature on CD focuses on immutable units of deployment without DSU capabilities; and only a fraction of deployment models advocate nodes pulling new releases instead of the traditional push model.

Research by~\cite{wielgus2013erlang} produced a mechanism for nodes to pull Erlang releases via the OS package manager \lstinline|apt|, including support for \acrshort{dsu}.

A different approach to release deployment relies on \emph{Nix}, a general purpose package manager borrowing ideas from functional programming: immutability, pure functions, and referential transparency.~\cite{nix1} Nix provides repeatable environments to build packages in.~\cite{erlangnix2}~presents a proof-of-concept research project to deploy Erlang/\acrshort{otp} projects using Nix, with no \acrshort{dsu} support.

\cleardoublepage
\section{Related Work}\label{sec:related_work}

There have been several attempts to automate deployment of Erlang/\acrshort{otp} projects, including bootstrapping nodes and \acrshort{dsu} support.

\emph{Edeliver}~\cite{edeliver,talk:edeliver} is a widely used tool to generate and deploy OTP releases from Erlang and Elixir projects. It handles pushing artifacts and configuration to multiple production servers via \acrshort{ssh}, and supports \acrshort{dsu}. Written in bash, it has no additional dependencies.

\emph{Bootleg}~\cite{bootleg} is a pure Elixir solution to automate build and deployment via \acrshort{ssh}. It provides special support for projects using the popular Elixir web framework Phoenix, and exposes various hooks to customize its behavior, but does not support \acrshort{dsu}.

\emph{Gigalixir}~\cite{gigalixir} is a fully featured \acrfull{paas} that offers hosting and deployment for Elixir projects in production, with support for \acrshort{dsu}, built on Kubernetes~\cite{bernstein2014containers}. They provide a \acrshort{cli} tool to attach a remote shell to the running node, and convenience commands to run database migrations and to set configuration.
