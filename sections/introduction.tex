\section{Introduction}

The contributions of this work are \begin{enumerate*}[label=(\roman*)]
  \item an extension to the pipeline described in~\cite{zak18} to bootstrap an Erlang/\acrshort{otp} (\emph{\acrlong{otp}}) node with a single command, which pulls artifacts from a central store and deploys them without interaction; and
  \item an analysis of possible failure modes and root causes that may prevent an upgrade from being applied successfully via \acrfull{dsu}.
\end{enumerate*} This section explains relevant terminology and shows where manual interaction is required to deploy \acrshort{otp} Releases.

\subsection{Erlang/OTP}

Erlang is a programming language for building concurrent, distributed systems with high availability requirements. Initially designed by Ericsson for telephone exchanges, it has been embraced by industries with similar needs: finance, gaming, betting, messaging, middleware, and databases. Development of Erlang took place starting in 1986 at the Ericsson Computer Science Laboratory, and in 1998 Erlang was released as Open Source.~\cite{armstrong2007history}

\acrshort{otp} stands for \acrlong{otp}, and is a combination of library applications, design patterns, conventions, and documentation. Erlang is almost always used in conjunction with \acrshort{otp}, hence the name Erlang/\acrshort{otp}.~\cite{ferd}

The language is often described as functional, although it is not strictly side effect free or referentially transparent. Erlang compiles to bytecode, which is executed by a \acrfull{vm}. The current Erlang \acrshort{vm} – the \emph{\acrshort{beam}}, short for \emph{\acrlong{beam}} – is written in C and supports various machine architectures. Multiple languages that compile to \acrshort{beam} bytecode have been created, most famously \emph{Elixir} and \emph{Lisp Flavored Erlang}. Actor model processes are the language's concurrency primitives: Functions can be spawned to create lightweight \acrshort{beam} processes. They are different from \acrfull{os} processes or threads, being preemptively scheduled by the \acrshort{beam}. Erlang/\acrshort{otp} systems commonly ``run millions of processes simultaneously [with each one taking] less than a kilobyte of space.''~\cite{larson}

\paragraph{\acrshort{otp} Applications.}
Erlang code is constructed out of functions defined within \mbox{\emph{module}} files bearing an \lstinline|*.erl| extension. \emph{\acrshort{otp} Applications} group related modules into reusable units to provide well-defined start and stop semantics, including an \emph{application resource file} (\lstinline|*.app|) containing additional metadata such as a version string and a list of other applications that this application depends on, and which need to be started beforehand. Every application has a dependency on at least \lstinline|kernel| and \lstinline|stdlib|, and both must be specified in the application resource file.~\cite{doc:otp}

\acrshort{otp} also enforces a certain directory structure for applications.~\cite{logan:otp}

\paragraph{\acrshort{otp} Releases.} Whole projects consisting of multiple applications are packaged and deployed as \acrshort{otp} Releases. They are described by a release resource (\lstinline|*.rel|) file, which specifies additional metadata, such as a version string for the entire release, the included version of the \emph{\acrlong{erts}} (\acrshort{erts}), and a list of applications with their respective version strings that comprise the release.

From this release resource file, various tools can be used to create a boot script and assemble the release into a single compressed tarball (\lstinline|*.tar.gz|) package.~\cite{doc:otp} A packaged release contains everything necessary to bootstrap an \emph{embedded target system} on another machine, also called a \emph{node}. Depending on the tool used to generate the release, it may include additional convenience scripts to upgrade or inspect the target system.

\paragraph{\acrlong{dsu}.} A core feature of Erlang is its support for \acrfull{dsu}, also referred to as on-the-fly upgrading, or hot code loading. The \acrshort{beam} keeps up to two versions of a module loaded in memory, and both versions of the code may run side by side.~\cite{cesarini:otp} \acrshort{otp} provides generic \emph{behaviours} that \emph{callback modules} can implement to normalize start, stop and upgrade semantics, among others.~\cite{doc:otp} Erlang systems constructed according to \acrshort{otp} patterns, grouped into \acrshort{otp} Applications, and packaged as \acrshort{otp} Releases enjoy additional support for \acrshort{dsu} via instruction files: \emph{\acrshort{appup}s} (\emph{\acrlong{appup}}) and \emph{\acrshort{relup}s} (\emph{\acrlong{relup}}).

First, there are high-level, often handwritten \acrfull{appup} files, one for each \acrshort{otp} Application. These files are fed into release generation tools where they are translated and combined into a single low-level \acrshort{relup} file, thus making a given release \acrshort{dsu}-capable.~\cite{doc:otp} The \acrshort{relup} file contains instructions on how to upgrade a node running a previous version. A single release package can include one \acrshort{relup} file which may know how to upgrade from multiple previous releases. These files also contain instructions on how to downgrade to the previous version in case the upgrade fails.~\cite{doc:otp}

\subsection{Problem}\label{sec:problem} Most existing release generation tools require manual interaction at various steps, and are generally not trivial to set up and use out of the box in a noninteractive build environment, such as a \acrfull{ci} pipeline. Additionally, there are some pitfalls when developers assemble releases on, for example, their \emph{macOS} development machines and then attempt to start them on \emph{Linux} in production~\cite{cesarini:otp}: This fails with a nonobvious error. To generate an \acrshort{otp} Release capable of \acrshort{dsu}, a developer needs to manually write \acrshort{appup} files and increment version numbers for all changed applications. The \acrshort{otp} Release resource file has an additional, separate version number that needs to be updated between commits to be able to perform \acrshort{dsu}. Then, to generate upgrade instructions, previous releases need to be fetched and unpacked. Lastly, the developer has to invoke various commands to assemble the final release package tarball.~\cite{ferd}

This process is tedious to perform manually, and impedes frequent deployment of small changes. Likewise, complex code changes are more likely to fail when applied via \acrshort{dsu}.~\cite{hicks} The unfortunate consequence is that developers are discouraged from using Erlang's \acrshort{dsu} capabilities unless absolutely necessary.~\cite{ferd}

\subsection{Contribution}

This work contributes design, implementation and evaluation of an extension to the build tool described in~\cite{zak18} for deploying Erlang/\acrshort{otp} Releases with support for \acrshort{dsu}. Its aim is to run without user interaction and to require as little configuration as possible. Additionally, the evaluation includes an analysis of \acrshort{dsu} failure modes.

\paragraph{Goal.} The goal is to develop a prototype implementation for bootstrapping an Erlang node with a single command. The node agent subscribes to the previously described release store to fetch release packages, download, extract, and deploy them; as well as apply \acrshort{dsu} instructions.

\paragraph{Method.} The thesis describes the architectural and design decisions made while iteratively implementing said node agent. The prototype is then used to tests the boundaries of the \acrshort{dsu} process. Finally, the work discusses limitations and advantages of the implementation.

\cleardoublepage
\subsection{State of the Art}\label{sec:sota}

The proposed tool, \emph{BeamUp}, relies on several layers of existing tooling, as visualized in Figure~\ref{fig:tools}. At the lowest level, Erlang/\acrshort{otp} ships with the \acrfull{sasl} that include the two basic building blocks for \acrshort{dsu} support: \lstinline|systools| provides low-level functions for \emph{offline} release generation, and \lstinline|release_handler| is used to perform an \emph{online} hot upgrade of a running node.~\cite{doc:otp}
Elixir projects are built with \lstinline|mix| (not pictured) and releases are generated with \lstinline|distillery|~\cite{distillery}, which handles generation of upgrade instructions itself, and directly interacts with \lstinline|systools|. Erlang projects, however, need more coaxing: Modules and dependencies are compiled with \lstinline|rebar3|, \acrfull{appup} files are generated on a best-effort basis by comparing \acrshort{beam} bytecode via a plugin to \lstinline|rebar3|~\cite{rebar3appup}, while release assembly is done by another intermediary tool, \lstinline|relx|~\cite{loder2016production}.

\vspace{2cm}
\begin{figure}[h]
  \begin{tikzpicture}[sibling distance=40mm,
    level distance=14mm,edge from parent,>=latex']
    \tikzstyle{edge from parent}=[draw,<-]
    \node (edeliver) at (0.9, 5) {\lstinline|edeliver|};
    \node (beamup) at (-2, 6.5) {\lstinline|beamup|};

    \node {\lstinline|SASL|} [grow'=up] {
      child {node {\lstinline|systools|}
        child {node (relx) {\lstinline|relx|}
          child {node (rebar3) {\lstinline|rebar3|}}}
        child {node (distillery) {\lstinline|distillery|}}}
      child {node (release_handler) [text=black!40] {\lstinline|release_handler|} edge from parent[draw=black!40]}
    };

    \node (appup) [left=10mm of rebar3,text centered,text width=13mm] {\lstinline|appup| \lstinline|plugin|};

    \draw[->] (appup) -- (rebar3);

    \draw[->] (edeliver) -- (distillery);
    \draw[->] (edeliver) -- (relx);
    \draw[->,draw=black!40] (edeliver) -- (release_handler);
    \draw[->,draw=black!40] (distillery) -- (release_handler);

    \draw[->] (beamup) -- (distillery);
    \draw[->] (beamup) -- (rebar3);
    \draw[->] (beamup) -- (appup);
    \draw[->,dashed,draw=black!40] (beamup.east) .. controls (5,6) and (2.3,5) .. node[very near start,sloped,above,text=black!40] {\small{(planned)}} (release_handler.32);

  \end{tikzpicture}
  \caption{Dependencies between selected tools to create and handle releases.}\label{fig:tools}
\end{figure}

\cleardoublepage
\section{Related Work}\label{sec:related_work}

There have been several attempts to automate Erlang/\acrshort{otp} release generation.

\emph{Sinan}~\cite{sinan} was a widely used tool to simplify assembling releases, but did not automate generation of \acrshort{appup}s. The project is deprecated since 2012.

\emph{Knit}~\cite{davis:knit,davis:talk} aimed for simple operation; requiring just one command to generate a \acrshort{dsu}-capable release from previous packages. Knit relied on the build tool \lstinline|rebar|, which–-unlike its successor \lstinline|rebar3|---included an algorithm similar to~\cite{rebar3appup} for generating \acrshort{appup}s. Knit optionally took metadata hints from the developer via \emph{module attributes} to guide \acrshort{appup} generation. The project was last updated in 2014 and appears to be abandoned.

\emph{Relflow}~\cite{relflow} integrates with the Git \acrfull{vcs} and automatically versions releases by rewriting the \lstinline|rebar3| config file. It uses its own \acrshort{appup} generation algorithm that relies on Git to detect what modules have changed between versions.

\emph{Tetrapak}~\cite{tetrapak} is an alternative release assembling tool that outputs artifacts as Debian packages. It too supports configurable automated versioning from \acrshort{vcs} commits, but has no support for \acrshort{dsu}.

\emph{Edeliver}~\cite{edeliver,talk:edeliver} shares very similar goals to the proposed tool. It supports Erlang and Elixir projects, coaxing any of the following tools used on a project: \lstinline|rebar|, \lstinline|relx|, \lstinline|exrm|, or \lstinline|distillery|. It generates releases capable of \acrshort{dsu} with configurable autogenerated version strings. To provide a repeatable build environment, Edeliver opens a \acrfull{ssh} tunnel to a separate build host and assembles the release remotely. Written in \lstinline|bash|, it has no additional dependencies. The tool also handles deployment via \acrshort{ssh}, including remotely performing \acrshort{dsu}.

A different approach to release assembling relies on \emph{Nix}, a general purpose package manager borrowing ideas from functional programming: immutability, pure functions, and referential transparency.~\cite{nix1} Its artifacts are identified via cryptographic hashes of all inputs used to build them. Nix provides repeatable environments to build packages in, similar to what containers are used for in this work, but with stronger determinism. Nix forms the base of \emph{NixOS}~\cite{nixos}, a full featured Linux distribution where almost all components are controlled by Nix via symbolic links.

Previous work by~\cite{erlangnix} allows dependencies of Erlang/\acrshort{otp} projects to be managed via Nix, relying on \cite{hex2nix} to provide Nix metadata, called \emph{Expressions}, for most of the Erlang and Elixir packages hosted on \lstinline|hex.pm|, the primary package repository of the Erlang/\acrshort{otp} ecosystem. Lastly,~\cite{erlangnix2}~presents a pipeline to deploy Erlang/\acrshort{otp} projects using Nix.
