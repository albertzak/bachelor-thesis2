\cleardoublepage
\section{Discussion}

The following two sections qualitatively review the contribution with respect to the stated goals, and expose limitations of the current implementation as well as discuss flaws inherent to the design.

\subsection{Advantages}

\paragraph{One time setup.} A node only needs to be started once, and it performs all subsequent upgrades without interaction.

\paragraph{Minimal dependencies.} The host running only needs to provide a way to start a container. The node does not interfere with the host system except an optional optional cache directory to save release packages, and the node agent does not attempt to listen on any ports by default. The connection to the store only requires outbound \acrshort{http}(S) and consequently should be able to bypass most firewalls.

\paragraph{Convenience tool.} There is a simple optional \acrshort{cli} tool to start a node with a single line. The tool does not need super user permissions, is not dependent on any specific package manager, and its only dependencies are Docker, \lstinline|curl|, \lstinline|bash| and Git. The operational node is started in a mostly transparent, privileged container; it can bind to any available host port, and communicate with attached hardware.

\paragraph{Bare container.} For production deployments, it is recommended to start the \lstinline|beamup/node| container and configure it with the exact kernel capabilities, filesystem mounts, and port mappings required for the target system. Any container orchestration tool can be used to deploy this container on any platform where containers run.

\paragraph{Multiple machine architectures.} The node agent should be able to run on various machine architectures for which official Erlang/OTP Docker images~\cite{docker:erlang} are available: \lstinline|amd64|, \lstinline|arm32v7|, \lstinline|arm64v8|, \lstinline|i386|, \lstinline|ppc64le|, \lstinline|s390x|.
Releases must be produced on the same target architecture, and the proposed pipeline ensures that nodes only attempt to start releases for the correct architecture. Note that the current implementation has not been tested on any machine architectures except \lstinline|amd64|.

\paragraph{Declarative.} The command to start a node is always the same. All settings such as authentication credentials for the store, or the name of the release to run are passed to the node agent via environment variables. If the release to be launched does not yet exist in the store, the node will not fail but subscribe and yield.

\paragraph{Local release cache.} The node agent caches release packages inside a single directory mounted from the host. This avoids having to download the same release package every time the node is restarted.

\paragraph{Normalized environment.} The node bootstrapping script detects whether it is being run directly on a host machine, in which case it attempts to normalize the environment by starting a container to run the node in. Otherwise, the agent assumes a recent version of Erlang/OTP to be available in the system path. The operational node is always started with the \acrshort{erts} from the release tarball.


% --
\cleardoublepage
\subsection{Limitations}

\paragraph{Operational node configuration.} Operational nodes must either pull their configuration from an external service at runtime, or the release package must be built with configuration included. While the proposed tool provides a way to set the node name and a distribution cookie, other lower-level configuration for certain parameters of the \acrshort{erts} cannot be changed after startup and thus must be part of the release package.

\paragraph{Static environment variables.} The current implementation requires multiple OS environment variables to be set before booting the node, e.g.~an authentication token to the store, and the name of the release to run. These values cannot be changes afterwards unless the node is restarted. Ideally, a node would require only one immutable identifier which it would use to pull this configuration from an external source.

\paragraph{Coupling of build step and deployment.} Whenever a new release is pushed into the store, all nodes immediately attempt to deploy it. The described pipeline currently has no way of separating these two phases.

\paragraph{Downloading the ERTS.} All release packages must include the \acrlong{erts} for the target architecture. Nodes do not cache these infrequently updated binaries separately, and download them as part of the compressed release package before each upgrade.

\paragraph{Agent and OS upgrades.} There is no support for upgrading the node agent.
% TODO: OS in container, added layer of complexity

\paragraph{Insecure defaults.} In an attempt to hide the fact that the operational node is running inside a container, starting a node via the convenience command boots the container in privileged mode and with host networking enabled. This allows the node to bind to any port available on the host without the need to specify port mappings, and to communicate with any attached hardware at the expense of isolation. At the same time, the node has no access to the host filesystem, thus breaking the mental model of transparent containerization.

\paragraph{Unofficial API.} The node agent does by design not directly interact with the release handler process of the operational node. Instead, the agent expects release packages to be built with included convenience scripts that allow the operational node to be started and upgraded. The APIs of these command scripts are not specified or standardized, as they are expected to be invoked by human operators. By accepting the detour via these shell scripts, release assembly tools may customize the upgrade process outside of the \acrshort{beam} and the facilities that OTP provides.

\paragraph{No eviction of old releases.} The current implementation of the node agent never deletes old artifacts from the local cache.
